## 微服务架构初识

### 警告

本文枯燥乏味，而且因为作者水平有限，可能有错误之处。阅读请谨慎。如果你慎重选择后决定阅读，欢迎交流。

### 基本概念

在开始之前，我们先说一些微服务架构中常见的术语。在引出各个术语之前，我们先对比下，以前的单体架构中，大概就是整个系统打包一个 war, 然后放到 tomcat 下，连接一个 db 一个 redis 等，所有业务服务都在这同一个 war 下，需要什么就直接调什么，每次部署就要全部重新部署。优势劣势很明显，优势就是架构简单,集中开发，所有调用都在在一个地方，没有 rpc/http 调用的损耗等，缺点也很明显，业务大了所有业务在一起就很复杂，一旦服务挂了就全部无法访问，总结就是效率低，维护难，稳定性差等...

![单体服务架构图](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-00.png "单体服务架构图")

再来对比一下简单的微服务架构图（注：这是网络拿的简单微服务架构图，后文还会展示更全更复杂的架构图，这里仅仅做开篇用一个简单的来做基本理念的区别）

![微服务架构图](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-01.png)

通过以上两个架构图对比，明显看到微服务中，各个服务是独立的，持有独自的数据库，数据库不会垮服务访问，如果需要访问其他微服务的数据，直接通过微服务调用。

所以微服务就是单纯把服务独立出来就结束了吗？
当然没有。
**我们的目标可是高性能、高并发、高可用的微服务！！！**
所以，就还需要注册中心、服务发现、负载均衡、服务通讯、熔断降级、配置中心、网关等

##### 注册中心

注册中心是什么？为什么需要注册中心？
其实注册中心和下面的服务发现是关联在一起的，但是先有注册中心，才能服务发现。所以顺序上就说注册中心了。根据上文，我们微服务现在把服务拆分了，各个服务独立管理自己的数据。然后服务之间的有业务通讯，就比如一个电视系统，商品库存一份微服务，用户一个微服务，订单一个微服务。那一个用户下单购买一个商品，肯定涉及上面的各个微服务。所有就有了服务间通信。如果每个微服务还像传统一样使用一个物理 ip 地址或者一个域名，可以嘛？用是可以用，但这样一旦对应机器出问题，怎么办？一个微服务一个域名，得申请多少域名呀？另外如果部署虚拟机也是，如果一个微服务需要拓展多个实例了？每次手动去修改所有调用他的微服务?那肯定不行。于是，注册中心就来了。

注册中心，就是允许服务向注册中心注册自己的服务以及拉取服务列表。这又什么好处？服务注册的时候获取注册是的 ip 地址，这样 ip 地址就是动态的，服务定时从注册中心同步服务列表，这样就可以根据服务名字获取实时的动态服务地址。某种意义，其实注册中心也像注册域名一样，但域名你要去万网等注册，如果是内网域名，那就得内网管理，这样各个系统的内网域名都放一起很乱，而通过注册中心，一个大系统中可以有数百个微服务，然后他们只需要同一个注册中心，他们的相互通讯地址，让统一的注册中心管理，他们只需要知道注册中心在哪里，client 向注册中心同步服务列表，server 向注册中心注册自己即可。注意，这里的 client 不要理解成 app 或者 web，就是一个服务，所以，一个微服务既可以是 client 也可以是 server。当他调用其他微服务，他就是作为 client，当他对外提供服务，让其他微服务调用，他就作为 server。(在本小节，且把 client 当做服务调用者，server 当做服务提供者)

这样听起来会不会觉得注册中心挂了是不是就全挂了？不慌，首先注册中心在部署时应该部署集群做高可用，其次还有下文即将提到的服务治理熔断等等...

##### 服务发现

现在，作为 server 的微服务已经向注册中心注册了自己，那作为 client 的如何发现它需要的 server，就是通过想注册中心同步服务列表。这样就实现了服务发现。简而言之，就是我们如何通过一个名字，能动态获取到服务的目标地址。感觉很像 dns 解析通过域名得到 ip 吧，差不多一个道理，只是你如果一个微服务一个域名那得申请很多域名，而现在这个微服务架构都会在一个大集群里，他们有自己的内网 ip，只需要通过服务名字即可找到它在集群的位置。关于这个 dns 解析，下文提到的 k8s 做服务发现，就有集群内 dns 解析的。所以基本理念都是，通过一个固定名字，找到服务的具体地址。

##### 服务治理

现在服务可以发现、调用了？还有什么问题，某个服务挂了怎么办，挂了还每次都去调用它，那不是就无法成功调用？因此，服务挂了要被对应的调用方知道。这就是治理！好，注意了，这里相对注册中心提到的 client 和 server 的概念，要进行一次重新定义。现在，无论是服务提供者还是消费者，都是 client，但主要是想说服务提供者, 然后 server 是注册中心(啥，怎么又变了？是不是很懵！不慌，因为在不同场景，对同一个术语可能有不同定义，要适应重新定义)。client 定期和 server 同步自己的状态，表明自己还正在良好运行中，一旦在一定时间无法和注册中心通讯，注册中心就把它移除，这样其他服务消费者同步 server 的服务列表就不包含它，下次调用就不会调用它了。那你又说，那不调用它我怎么完成这个任务？？别急，后面还有负载均衡和熔断降级呢。

现在明白了，服务治理简单来说就是要保持一个准确的服务列表，一个新服务注册后要能让其他消费者获取到这个服务，一个服务反注册或者长期断线后，要移除这个服务。如果突然断网了，所有服务都断线了，或者注册中心全部挂了怎么办？这里都有一些机制，比如为了避免突然挂了，如果短时间内所有服务失联，注册中心会进入自我保护状态，不会一下子全部移除这些服务。对于注册中心挂了，client 每次同步都缓存获取到的服务列表，如果暂时拿不到新的，就会直接用缓存的服务列表去访问。

**针对注册中心、服务发现、服务治理,Spring 全家桶中使用 Netflix 的 [Eureka](https://github.com/Netflix/eureka) 框架，而国内比较倾向于使用 rpc 框架的 [Dubbo](http://dubbo.apache.org/zh-cn/)，其自身包含服务治理功能，Dubbo 注册中心可以使用[Zookeeper](https://zookeeper.apache.org/) 或者 [Redis](https://redis.io/)，官方推荐 zk**

##### 负载均衡

来到了负载均衡，刚刚上面提到如果服务失联了，注册中心移除这个服务，我没有这个服务怎么办？第一，我们微服务在设计和部署时，一定要支持水平拓展，动态部署多实例。为什么要这么设计，因为你要能支持水平拓展，才能在流量高峰来临是动态扩容，保证服务稳定运行。除此之外，某个微服务如果想做灰度，也可以一部分实例部署灰度版本，一部分实例部署正常版本，这样就可以做新特性尝试了(当然做了灰度还有其他要考虑的，比如那些用户的请求转发到灰度版本，那些用户请求转发到正常版本)。所以呢，为了我们的目标：高性能、高并发、高可用的微服务架构，肯定是要部署多实例了，既然部署了多实例，那说明一个服务名字可能就对应多个具体服务实例，一对多的关系了。继续回到上文，服务治理中服务失联或者反注册后，如果还有其他实例，那就可以继续用其他实例来提供服务。

那一个服务既然有多个实例，肯定要涉及负载均衡了。负载均衡就是一个请求，我如何决定这个请求交给那个服务处理。HAProxy,Nginx 等都提供一定的负载均衡功能，但这部分可能倾向于将不同请求转发到不同服务，而在这里，是针对同一个服务有多个实例，选择那个服务去处理，要注意两者的区别。所以，负载均衡就是选择那个实例服务，既然服务都是提供一致的功能，那理论选择哪个都能提供，只是我们目标就是，来，大声一起说：高性能、高可用、高并发的微服务架构。所以一定要保证负载合理，不能一个实例处理太多导致性能很低，另一个服务完全不用处理。这样就达不到我们的目标了。所以选择一个实例来处理请求很重要。常见的有随机选择(那肯定不是很符合我们期待，毕竟随机哪个实例处理多那个实例处理少不确定)、轮询(这可能就是常见的方式，这样基本把请求合理分配出去)、根据权重(这可能考虑特殊情况，比如某个实例分配的机器资源更丰富，可以考虑分配它多一点)。

另外关于负载均衡，还有客户端负载和服务端负载，这里暂不区分。再 Spring 全家桶中，负载均衡使用的是 Netflix 的 [Ribbon](https://github.com/Netflix/ribbon)。rpc 框架的[Dubbo](http://dubbo.apache.org/zh-cn/) 框架自身也包含了负载均衡

既然提到了负载均衡，我简单描述下常见的负载均衡算法

- 轮询法
- 随机法
- 源地址哈希法
- 加权轮询法
- 加权随机法
- 最小连接数法

##### 熔断/降级

再次回到服务治理，如果服务挂了怎么办？第一次我们说我们应该考虑部署多实例，从而引出另一个话题负载均衡，那这次我们假设没有多实例或者同一时间，所有实例都挂了、或者服务虽然还在，但是请求就是各种异常，或者网络很慢长期得不到响应，我们就等呀等，一直等到超时，每个请求都这样，岂不是很多请求都在等呀等的，然后就导致堆积大量请求，最后导致这个服务也挂了。。。然后另一个调用这个服务的，也等呀等。。。然后也。。。可怕，这样下去岂不是雪崩？这时候，熔断，服务降级就来了。

熔断，就是保险丝在超出负载好避免发生事故的一种自我保护机制，而上面我们也是发现其他服务长期无响应,它的简单理解就是我们每次请求一个服务都记录一下，加入这个请求发生异常，记录一次，两次。。。如果在一定时间内服务都是异常，那么为了避免我们一直请求异常带来的影响，就触发熔断，熔断发生后，客户端尝试继续请求时，就不会去请求，而是进入一个服务降级状态。那什么时候恢复呢？当到一个时间后，开始进入半熔断状态，这时候部分过来的请求会真正去请求服务提供者，部分请求还会进入服务降级状态，一旦某个真正去请求的可以请求成功了，那就关闭熔断，进入正常状态。后续请求全部进入正常请求中。

服务降级，就是在熔断或者请求符合一定异常情况下，进入的一个服务降级状态，不会向请求端报错，而是返回一个统一降级处理的信息。举个栗子，比如 A-B 两个微服务是两种账号体系，一部分 A 用户持有 B 系统账号，一部分没有，每次去 A 系统都要再去 B 获取是否有 B 系统账号，如果 B 系统异常了，这时候的服务降级可以是进入到这个 A 账户没有 B 系统账户的情况中(你不要和我说为啥不在 A 直接记录呀，这里是举个栗子)。

Spring 全家桶中需要通过 Netflix 的 [Hystrix](https://github.com/Netflix/Hystrix) 实现服务降级，[Dubbo](http://dubbo.apache.org/zh-cn/) 自身也是包含服务降级的

##### 服务通讯

服务通讯其实就是服务间调用，上面提到的一系列功能都是围绕服务通讯。服务通讯有两种方式，一种是 http ，一种是 rpc 。Spring 全家桶主要通过 http，其服务通讯使用 [Feign](https://github.com/OpenFeign/feign)，但其本质都是 http，所以其他 http 客户端都可以实现，比如 [Retrofit](https://github.com/square/retrofit) ，而 [Dubbo](http://dubbo.apache.org/zh-cn/) 是 rpc 的方式，其协议是自定义的 dubbo 协议，只能使用它自己的方式。

##### 配置中心

配置中心，其实就是 application.yaml 上面的配置值的动态修改。为什么需要配置中心。
举一个具体的例子，某天某短信服务挂掉，然后用户疯狂点击发送短信，服务还是记录他请求了短信，但短信其实没有发出，而此系统限制每个用户每天只能发 10 次，那个用户就投诉了，客服表示很急，要求修改。结果这边回复修改需要重启，因为是放在环境变量，现在是。。。无法重启。你看，这个场景就很适合用配置中心，可偏偏不用，服气吧（当然线上部署了多实例，其实是一个先重启一部分修改，这里就不讨论运维没有做好重启部分实例工作，直接一刀切）。而这个东西本身就应该动态配置，虽然他们通过环境变量配置了，但是居然没有配置中心，傻眼了吧。
另外，上面举例使用配置中心修改及时生效无需重启的场景，单并不是说使用类配置中心任何修改都不需要重启。举个栗子，对于数据库连接池，消息中心地址等，或者某些配置虽然是动态配置但其实服务启动后立刻将其值复制到某些配置中自己管理，后续不再使用新的值，因此不重启也是无法生效的。简单来看就是每次使用这个值是否正好对应配置中心修改的值。如果不是就不生效。

配置中心框架

- Spring 自家配置中心是 [Spring-Cloud-Config](https://spring.io/projects/spring-cloud-config)(不推荐)
- 携程开源的 [Apollo](https://github.com/ctripcorp/apollo)(推荐，笔者使用不错)
- [Nacos](https://nacos.io/zh-cn/)(推荐，阿里出品，目前使用也挺多)
- 其他，有一些其它也听有名，但可能不维护了，要选择还在积极维护的

##### 网关

好了，现在我们已经服务化了，现在有很多微服务，细分的同时也会带来零碎，接口太多了，很多统一功能各个微服务都要编写，岂不是麻烦？而且管理接口也很麻烦。这是由就需要一个统一网关。有一个统一网关后，所有通用功能都在网关处理，这样注入权限验证、限流、审计日志、黑白名单等，不同统一网关提供一些不同的功能。Spring 全家桶包含一个 Netflix 的 [zuul](https://github.com/Netflix/zuul)，另外还有如 [kong](https://konghq.com/) 等非常有名的网关。个人推荐 kong，因为 kong 能把网关功能也业务功能更充分解耦。

**会不会觉得每个概念都讲得啰里啰嗦的，都叫你别看了还看。因为笔者是从移动端开发转过来的，因此会尝试从移动端过来的小白用户交流，因此也会当读者是这样的小白用户来沟通**

### 常见 Spring Cloud 全家桶微服务

###### ps 不想写了直接盗图，参见最后引用部分

![](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-02.png)

### 某公司 Spring Cloud + K8s + HAProxy + Kong 微服务架构

![](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-03.jpg)
一个请求可能涉及的完整流程如下:

1. app 端发送请求 https 请求，请求的地址是 [HAProxy](https://github.com/haproxy/haproxy) 服务器地址
2. haproxy 接受到地址后，将请求进行转发到 kong 网关或其他服务地址，注意比如某些服务如内部 git，wiki 等没有部署经过 kong,这个请求就直接转到到对应的服务器。而业务服务有个统一网关 kong，这部分就转发到 kong。转发同时将 https 转 http。
3. 在 kong 上我们会部署每个 server 和对应 router，kong 根据收到请求的 url 去匹配 router,匹配到之后交给对应的 service
4. kong 根据路由匹配 service 的时候，此时 service 已经是 k8s 内的一个 service,这个 service 可以部署多个 pod,这分发的负载均衡就由 k8s 去调度。
5. 请求最后就交到了具体服务上，然后服务就根据业务处理，需要查 redis 的查 redis，需要查 mysql 的查 mysql。到这一步就主要是我们写的代码了。

接下来从分层角度聊一聊这个架构

1. **接入层** [HAProxy](https://github.com/haproxy/haproxy) 可以做 4 层 7 层负载均衡，并发高但其是单进程模式，可以将 https 转化成 http。我们使用它主要利用其 7 层负载均衡和 https 转 http 的功能。这一个是独立不是再一台机器上，不是部署在 k8s 集群。要知道，外部流量都是先经过这里。

2. **接入层** [kong](https://konghq.com/) 使用 kong 我们同时用了一个界面工具 [konga](https://github.com/pantsel/konga)，简单理解可以为一个 gui 工具，当然他们远不止如此。kong 是基于 nginx 上的一个插件，我们这边没有直接部署 nginx,用了 kong 你就想底层包含 nginx 或者 OpenResty(OpenResty 也是几乎 nginx)。他可以做权限验证、限流、黑白名单等。但我们都没有使用这些，因为是用 lua 脚本写。因此当初技术研发不熟放弃了，直接转到 java 层面在做验证。至于限流，我们的这点流量，巴不得再来多一点。另外我们使用了 kong 网关，因此没有使用 zuul。

3. **应用层** 在进入到应用层时，也会经过一些负载均衡的处理。上文提到的负载均衡，我们这里可以有两个地方，但是作用是不同的。一个是 HAProxy ，但这部分只是做不同服务器的负载均衡，提供的功能各不相同。经过 kong 进入服务之后，请求到 k8s 也会有一个负载均衡，一方面是不同服务转发到不同组件，另一方面同一个组件可能包含多个 pod ，会根据负载均衡算法选出一个 pod 来处理任务。因此我们也没有用到 Ribbon。

4. **储存层** 储存层包含 redis 缓存和 mysql 数据库。这里要注意。微服务中我们说每个微服务独自一个数据库，这里是独自一个 db，不是独自一个 mysql ，mysql 还是连接同一个，但使用不同 db ,不同 db 创建不同账号去访问。另外关于 mysql 、redis 的部署也有单点、主从、哨兵、集群等模式。 redis 主要就是内存缓存，但我们这边主要是部分常用数据，比如用户信息等会高频使用，其他因为本身量也比较少，很多业务直接就查 mysql。

5. 在架构图中，除了以上四层，我们还包含两侧的部分系统。比如左侧的 [Kafka](http://kafka.apache.org/) 和 [ZooKeeper](http://zookeeper.apache.org/)，ZK 是什么大家可以自己查一下，简单说就是一个分布式协调工具，除了这里的 kafka 部署用到它他，上文也提到 dubbo 也可以用它做注册中心。消息中间件的作用基本就是异步、解耦、削峰等，而 apollo 这个做配置中心，替换 Spring-Cloud-Config。
6. 右侧主要展示一些 CI/CD 和运维监控工具。这个大家基本了解下。
   [gogs](https://gogs.io/) 代码仓库
   [drone](https://drone.io/) CI/CD，根据 drone 脚本，可以构建，打镜像，部署环境
   [elk](https://www.elastic.co/) (Elasticsearch + Logstash + Kibana) 日志收集处理查看
   [pinpoint](https://naver.github.io/pinpoint/) java 程序性能监控和组件调用
   ![pinpoint监控示例图](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-04.jpg)
   [grafana](https://grafana.com/) 也是一个监控工具
   ![grafana-kong监控](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-05.jpg)
   ![grafana-redis](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-06.jpg)
   ![grafana](https://github.com/ZoroRe/3D2Y/blob/master/media/images//Micro-Service-Arch-07.jpg)

### 说明

本文只是一个对微服务架构，包括部分监控支撑工具的初识，提到的东西很多读者想了解还需要自行了解。并且只是根据资料和某公司的一些案例展示，未必能作为最佳实践，想做一个最佳实践的读者应当多自行查看资料。

### 参考

[微服务架构]("https://www.cnblogs.com/imyalost/p/6792724.html")

[SpringCloud 微服务架构图](https://blog.csdn.net/fzy629442466/article/details/85339960)
